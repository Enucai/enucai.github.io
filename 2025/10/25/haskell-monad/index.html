<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="NetSpeed1">



    <meta name="description" content="Blog">



<title>Haskell 中的 Monad | Netspeed1</title>



    <link rel="icon" href="/images/icon-round.jpg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 8.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">NetSpeed1</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">NetSpeed1</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Haskell 中的 Monad</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">NetSpeed1</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 25, 2025&nbsp;&nbsp;12:00:20</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/EECS-courses/">EECS courses</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>Haskll 的 Monad 其实是针对一个 type constructor 的定义。</p>
<p>所谓 type constructor，就是类型构造器，他接收一个或若干个类型，产生一个新的类型。例如 <code>Maybe a</code>，其中 <code>a</code> 是一个 type，而 <code>Maybe</code> 就是一个 type constructor。又如 <code>[a]</code>，其中的 <code>[]</code> 即为一个 type constructor，传入一个类型 <code>a</code>，会构造一个 <code>a</code> 的列表的 type。</p>
<p>我们可以大致认为一个 type constructor 就是一个盒子，他就是把一个 <code>a</code> 类型的值给装进了一个盒子里。虽然这种比喻有些时候并不完全恰当。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>Monad 体系内最先被定义的是 Functor。考虑函数 <code>map</code>，它的类型是 <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>，即给 <code>[a]</code> 内的每个元素都作用上 <code>a -&gt; b</code> 的函数。但是该定义只对 list 这个 type constructor 有效。我们希望将这个函数普适到其他的 type constructor。</p>
<p>而所有能被作用这样类似 <code>map</code> 函数的 type constructor，我们统一定义其为 Functor class。</p>
<p>Functor 这个 class 的定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  (&lt;$) :: a -&gt; f b -&gt; f a</span><br><span class="line">  (&lt;$) = fmap . const</span><br></pre></td></tr></table></figure>

<p>其中后面两行其实是对 <code>fmap</code> 进行符号化的定义，本质定义只有第二行，即我们只需要对于这个 type constructor 定义一个 <code>fmap</code> 函数。函数的作用就是给定一个 <code>a -&gt; b</code> 的函数，然后再给一个用 <code>f</code> 包裹住 <code>a</code> 的类型，要将盒子里的每个元素都做用一下 <code>a -&gt; b</code> 的函数，最后得到一个用 <code>f</code> 包裹住 <code>b</code> 的结果。</p>
<p>如果我们把 <code>f</code> 当作是 <code>[]</code> 这个 constructor，那么就很容易这是在干什么了。定义 <code>[]</code> 的 Functor 可以写作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">  fmap = map</span><br></pre></td></tr></table></figure>

<p>因为对于 list 来说，<code>fmap</code> 就是 <code>map</code>。</p>
<p>我们再来看 <code>Maybe</code> 这个 type constructor 的 Functor 应该怎么写：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap _ <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">  fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> $ f x</span><br></pre></td></tr></table></figure>

<p>还有 <code>IO</code> 的 Functor：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap f mx = <span class="keyword">do</span></span><br><span class="line">    x &lt;- mx</span><br><span class="line">    return $ f x</span><br></pre></td></tr></table></figure>

<p>然后 Prelude 中还对 Functor 定义了一个运算符：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br></pre></td></tr></table></figure>

<p>就是我们可以用 <code>&lt;$&gt;</code> 这个中缀来代替 fmap，这个的作用在下面会有体现。</p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>在上面 Functor 中，我们只能对一个给定的 <code>a -&gt; b</code>，去 map over 一个 <code>f</code> 包裹的 type。Applicative 其实是对 Functor 的一个扩展，它将定义一个 <code>&lt;*&gt;</code> 函数，可以给定一个 <code>f</code> 包裹的 <code>a -&gt; b</code>，再给定一个 <code>f</code> 包裹的 <code>a</code>，得到一个 <code>f</code> 包裹的 <code>b</code>。具体来说，其定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>

<p>它定义了两个函数：<code>pure</code> 和 <code>&lt;*&gt;</code>。其中 <code>&lt;*&gt;</code> 就是上面所说的，给定一个用 <code>f</code> 包裹的 <code>a -&gt; b</code> 函数，再给定一个用 <code>f</code> 包裹的 <code>a</code>，返回一个 <code>f</code> 包裹的 <code>b</code>。</p>
<p>而 <code>pure</code> 则是一个用于构造单位量的函数，给定一个 <code>a</code> 类型的变量，返回他用 <code>f</code> 包裹后的结果。</p>
<p>我们还是以 <code>Maybe</code> 为例来看一下如何将它变成 Applicative 的实作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">  pure = <span class="type">Just</span></span><br><span class="line">  <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">  (<span class="type">Just</span> f) &lt;*&gt; mx = g &lt;$&gt; mx</span><br></pre></td></tr></table></figure>

<p>首先考虑 <code>pure</code>，显然就是直接装进 <code>Just</code> 即可。然后是 <code>&lt;*&gt;</code>，传入的第一个值就是一个 <code>Maybe</code> 包裹的 <code>a -&gt; b</code> 的函数，那么如果这个函数是 <code>Nothing</code>，结果必然是 <code>Nothing</code>，否则直接将 <code>a -&gt; b</code> 的函数取出，使用 Functor 中的 <code>fmap</code> 进行作用即可。</p>
<p>再看 list 的 Applicative 是怎么定义的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">  pure x = [x]</span><br><span class="line">  fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>

<p>先看 <code>pure</code>，单个元素装入 list 就是直接构造只包含一个元素的 list。对于 <code>&lt;*&gt;</code>，则是取出 <code>fs</code> 中的一个函数 <code>f</code>，再取出 <code>xs</code> 中的一个值 <code>x</code>，将所有 <code>f x</code> 拼成一个 <code>b</code> 类型的 list 即可。同时，我们也可以用 <code>fmap</code> 来定义 <code>&lt;*&gt;</code> 运算：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">  pure x = [x]</span><br><span class="line">  fs &lt;*&gt; xs = concat [fmap f xs | f &lt;- fs]</span><br></pre></td></tr></table></figure>

<p>这种写法和上面的没有本质区别。接下来列举 list 类型的一种示例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">1</span>) &lt;*&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">3</span>),(*<span class="number">3</span>)] &lt;*&gt; [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; pure (*) &lt;*&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;*&gt; [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br></pre></td></tr></table></figure>

<p>前两个示例很容易理解，第三个示例可以认为是从左往右逐个运算，第一部分是一个 <code>(&lt;*&gt;) :: f (Int -&gt; Int -&gt; Int) -&gt; f Int -&gt; f (Int -&gt; Int)</code>，然后变成了 <code>[(*1),(*2),(*3)]</code>，再作用到最后一个 list 上，得到答案。</p>
<p>然后还有 IO 类型的 Applicative：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">  pure = return</span><br><span class="line">  mg &lt;*&gt; mx = <span class="keyword">do</span> &#123;g &lt;- mg; x &lt;- mx; return (g x)&#125;</span><br></pre></td></tr></table></figure>

<p>一个示例是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getChars</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> <span class="type">String</span></span><br><span class="line"><span class="title">getChars</span> <span class="number">0</span> = return []</span><br><span class="line"><span class="title">getChars</span> n = pure (:) &lt;*&gt; getChar &lt;*&gt; getChars (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这个过程很好理解。然后 Applicative 还有一个经典应用是 <code>sequenceA</code>，他的定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sequenceA</span> :: <span class="type">Applicative</span> f =&gt; [f a] -&gt; f [a]</span><br><span class="line"><span class="title">sequenceA</span> []     =  pure []</span><br><span class="line"><span class="title">sequenceA</span> (x:xs) =  pure (:) &lt;*&gt; x &lt;*&gt; sequenceA xs</span><br></pre></td></tr></table></figure>

<p>他的作用可以根据定义看出来，当然我们可以看他在 <code>Maybe</code>，list 等上的表现：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">1</span>, <span class="type">Just</span> <span class="number">2</span>, <span class="type">Just</span> <span class="number">3</span>]</span><br><span class="line"><span class="type">Just</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">1</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">3</span>]</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>

<p>也就是说只要 list 中有一个元素是 <code>Nothing</code>，结果就会是 <code>Nothing</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]]</span><br></pre></td></tr></table></figure>

<p>这其实就是每个 list 内选一个元素连起来，形成的所有 list 再组成一个 list 的结果。</p>
<p>而对于 <code>IO</code> 类型，我们也可以把上面写的 <code>getChars</code> 写成 <code>sequenceA</code> 的形式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">getChars</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> <span class="type">String</span></span><br><span class="line"><span class="title">getChars</span> n = sequenceA [replicate n getChar]</span><br></pre></td></tr></table></figure>

<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>之前说的 Applicative 是 Functor 的扩展版本，那么再扩展一下就有了 Monad。Monad 主要定义的函数是 <code>(&gt;&gt;=)</code>，他的类型是 <code>(&gt;&gt;=) :: (m a) -&gt; (a -&gt; m b) -&gt; (m b)</code>。这里把 type constructor 从字母 <code>f</code> 变成了 <code>m</code> 也体现了这一 type constructor 的 Monad 属性。也就是我们有一个 <code>a</code> 到 <code>m b</code> 的函数，要把它作用到 <code>m a</code> 内装着的元素里，得到 <code>m b</code>。这么定义有什么作用我们等会儿再来说。</p>
<p>先来看一下 Monad 的形式化定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  return = pure</span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  m &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br></pre></td></tr></table></figure>

<p>可以看到定义中有三个函数：<code>return</code>，<code>(&gt;&gt;=)</code> 和 <code>(&gt;&gt;)</code>。首先看 <code>return</code>，它的作用是给定一个元素，返回只包含他的对应 type 的单位量。发现其作用就是 Applicative 中的 <code>pure</code>，而 Monad 就是由 Applicative 拓展而来的，因此直接使用 <code>return = pure</code> 来定义即可。</p>
<p>然后再看 <code>(&gt;&gt;=)</code>，这个函数也是 Monad 的关键，可以读作 bind。它的类型和作用在上面已经介绍了。然后看 <code>(&gt;&gt;)</code>，他给定了一个 <code>m a</code> 和一个 <code>m b</code>，然后只返回 <code>m b</code>，方式是将 <code>m a</code> bind 到一个无论传入何值，都直接返回给定的 <code>m b</code> 的函数上。</p>
<p>注意到 <code>return</code> 是从 Applicative 的 <code>pure</code> 引入的，<code>(&gt;&gt;)</code> 又是根据 <code>(&gt;&gt;=)</code> 定义好的，因此如果我么希望实作一个 type constructor，其实只需要定义他的 <code>(&gt;&gt;=)</code> 函数即可。</p>
<p>还是先来看一下 <code>Maybe</code> 的 Monad 应该如何定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="type">Nothing</span> &gt;&gt;= _ = <span class="type">Nothing</span></span><br><span class="line">  (<span class="type">Just</span> x) &gt;&gt;= f = f x</span><br></pre></td></tr></table></figure>

<p>这个定义是显然的，如果 <code>m a</code> 是 <code>Nothing</code> 那么返回值就是 <code>Nothing</code>，否则把 <code>m a</code> 里面的值取出来，作用一下 <code>f</code> 即可。来看几个例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">9</span> &gt;&gt;= \x -&gt; return (x * <span class="number">10</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">90</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &gt;&gt;= \x -&gt; return (x * <span class="number">10</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>

<p>然后来看 list 的 Monad 定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></span><br><span class="line">  xs &gt;&gt;= f = [y | x &lt;- xs, y &lt;- f x]</span><br></pre></td></tr></table></figure>

<p>其实就是把 <code>m a</code> 里的每个元素取出来，作用一下 <code>f</code> 能够得到一个 <code>m b</code>，然后再把 <code>m b</code> 里的元素全部取出来造成一个 list。因此 list 的 Monad 定义也可以写作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></span><br><span class="line">  xs &gt;&gt;= f = cancat . (map f xs)</span><br></pre></td></tr></table></figure>

<p>同样也可以看一些例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &gt;&gt;= \x -&gt; return (<span class="number">4</span> * x)</span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &gt;&gt;= \x -&gt; (replicate <span class="number">4</span> x)</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &gt;&gt;= \n -&gt; [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>] &gt;&gt;= \ch -&gt; return (n, ch)</span><br><span class="line">[(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="Monad-的链式结构"><a href="#Monad-的链式结构" class="headerlink" title="Monad 的链式结构"></a>Monad 的链式结构</h3><p>Monad 的函数写作 <code>(&gt;&gt;=)</code> 和 <code>(&gt;&gt;)</code>，这可以在写代码时写出一个链式的结构。比如考虑下面这个问题：</p>
<blockquote>
<p>皮尔斯决定要辞掉他的工作改行试着走钢索。他对走钢索蛮在行的，不过仍有个小问题。就是鸟会停在他拿的平衡竿上。他们会飞过来停一小会儿，然后再飞走。这样的情况在两边的鸟的数量一样时并不是个太大的问题。但有时候，所有的鸟都会想要停在同一边，皮尔斯就失去了平衡，就会让他从钢索上掉下去。</p>
<p>我们这边假设两边的鸟差异在三个之内的时候，皮尔斯仍能保持平衡。所以如果是右边有一只，左边有四只的话，那还撑得住。但如果左边有五只，那就会失去平衡。</p>
<p>我们要写个程序来仿真整个情况。我们想看看皮尔斯究竟在好几只鸟来来去去后是否还能撑住。</p>
</blockquote>
<p>那么我们先来定义一个 <code>type</code> 表示杆子的状态：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Birds</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Pole</span> = (<span class="type">Birds</span>, <span class="type">Birds</span>)</span></span><br></pre></td></tr></table></figure>

<p>然后我们就可以用 <code>Maybe Pole</code> 来表示当前状态：若为 <code>Nothing</code> 则表示已经失去平衡，否则表示两边各有多少鸟。可以写出如下两个函数来表示在杆子上停鸟的过程：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">landLeft</span> :: <span class="type">Birds</span> -&gt; <span class="type">Pole</span> -&gt; <span class="type">Maybe</span> <span class="type">Pole</span></span><br><span class="line"><span class="title">landLeft</span> n (left, right)</span><br><span class="line">  | abs((left + n) - right) &lt; <span class="number">4</span> = <span class="type">Just</span> (left + n, right)</span><br><span class="line">  | otherwise                   = <span class="type">Nothing</span></span><br><span class="line">  </span><br><span class="line"><span class="title">landRight</span> :: <span class="type">Birds</span> -&gt; <span class="type">Pole</span> -&gt; <span class="type">Maybe</span> <span class="type">Pole</span></span><br><span class="line"><span class="title">landRight</span> n (left, right)</span><br><span class="line">  | abs(left - (right + n)) &lt; <span class="number">4</span> = <span class="type">Just</span> (left, right + n)</span><br><span class="line">  | otherwise                   = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>

<p>那么如果我们先往 <code>landLeft</code> 里面穿一个参数 <code>n</code>，即 <code>landLeft n</code>，这就是一个 <code>Pole -&gt; Maybe Pole</code> 的函数，符合 Monad 的要求。因此，一个过程就可以被表示为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; return (<span class="number">0</span>, <span class="number">0</span>) &gt;&gt;= landRight <span class="number">2</span> &gt;&gt;= landLeft <span class="number">3</span> &gt;&gt;= landRight <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> (<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="title">ghci</span>&gt; return (<span class="number">0</span>, <span class="number">0</span>) &gt;&gt;= landRight <span class="number">2</span> &gt;&gt;= landLeft <span class="number">6</span> &gt;&gt;= landRight <span class="number">2</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>

<p>如果中途还有一个状态直接导致不合法，那么就可以用 <code>(&gt;&gt;)</code> 函数来表示：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; return (<span class="number">0</span>, <span class="number">0</span>) &gt;&gt;= landRight <span class="number">2</span> &gt;&gt;= landLeft <span class="number">3</span> &gt;&gt; <span class="type">Nothing</span> &gt;&gt;= landRight <span class="number">2</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>

<h3 id="Monad-的-Do-表示法"><a href="#Monad-的-Do-表示法" class="headerlink" title="Monad 的 Do 表示法"></a>Monad 的 Do 表示法</h3><p>有些时候我们定义一个函数，可能需要在 lambda 内套用 <code>(&gt;&gt;=)</code>，比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &gt;&gt;= (\x -&gt; <span class="type">Just</span> <span class="string">&quot;!&quot;</span> &gt;&gt;= (\y -&gt; <span class="type">Just</span> (show x ++ y)))  </span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;3!&quot;</span></span><br></pre></td></tr></table></figure>

<p>这时候写成一层套一层的结构就会很丑，因此 Haskell 还支持了 Do 表达式。我们把上面那句话分行写：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">foo</span> = <span class="type">Just</span> <span class="number">3</span>   &gt;&gt;= (\x -&gt;</span><br><span class="line">      <span class="type">Just</span> <span class="string">&quot;!&quot;</span> &gt;&gt;= (\y -&gt;</span><br><span class="line">      <span class="type">Just</span> (show x ++ y)))</span><br></pre></td></tr></table></figure>

<p>那么 Do 表达式的用处就是让他变得好看，可以写作：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">foo</span> = <span class="keyword">do</span></span><br><span class="line">    x &lt;- <span class="type">Just</span> <span class="number">3</span></span><br><span class="line">    y &lt;- <span class="type">Just</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="type">Just</span> (show x ++ y)</span><br></pre></td></tr></table></figure>

<p>同样的，上一段中所写的链式结构：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; return (<span class="number">0</span>, <span class="number">0</span>) &gt;&gt;= landRight <span class="number">2</span> &gt;&gt;= landLeft <span class="number">3</span> &gt;&gt;= landRight <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> (<span class="number">4</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>也可以被写作 Do 表达式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">routine</span> :: <span class="type">Maybe</span> <span class="type">Pole</span></span><br><span class="line"><span class="title">routine</span> = <span class="keyword">do</span></span><br><span class="line">        start &lt;- return (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        first &lt;- landRight <span class="number">2</span> start</span><br><span class="line">        second &lt;- landLeft <span class="number">3</span> first</span><br><span class="line">        landRight <span class="number">2</span> second</span><br></pre></td></tr></table></figure>

<p>运行就有：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; routine</span><br><span class="line"><span class="type">Just</span> (<span class="number">4</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>所以 Do 的本质其实是一个语法糖，但是却让 Haskell 这个函数式的编程语言有了命令式的感觉。</p>
<h2 id="Laws"><a href="#Laws" class="headerlink" title="Laws"></a>Laws</h2><p>还有一部分内容是有关 Functor，Applicative 和 Monad 的 Laws，所有定义这三种 type class 的函数都必须满足其对应的 Laws。</p>
<p>这一部分有一些范畴论的内容，下面的解释不一定完全正确。</p>
<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>任何一个 Functor 的实例，都必须满足如下两个性质：</p>
<ol>
<li><code>fmap id === id</code></li>
<li><code>fmap (f . g) === fmap f . fmap g</code></li>
</ol>
<h3 id="Applicative-Laws"><a href="#Applicative-Laws" class="headerlink" title="Applicative Laws"></a>Applicative Laws</h3><p>任何一个 Applicative Functor 的实例，都必须满足如下性质（标注内容是对应的类型分析）：</p>
<ol>
<li><p><code>pure id &lt;*&gt; x === x</code></p>
<ul>
<li>若 <code>id :: a -&gt; a</code>，则 <code>x :: f a</code></li>
</ul>
</li>
<li><p><code>pure (g x) === pure g &lt;*&gt; pure x</code></p>
<ul>
<li>若 <code>x :: a</code>，则 <code>g :: a -&gt; b</code>，<code>pure (g x) :: f b</code></li>
</ul>
</li>
<li><p><code>x &lt;*&gt; pure y === pure (\g -&gt; g y) &lt;*&gt; x</code></p>
<ul>
<li>若 <code>y :: a</code>，则 <code>x :: f (a -&gt; b)</code>，<code>pure (\g g -&gt; y) :: f ((a -&gt; b) -&gt; b)</code></li>
</ul>
</li>
<li><p><code>x &lt;*&gt; (y &lt;*&gt; z) === (pure (.) &lt;*&gt; x &lt;*&gt; y) &lt;*&gt; z</code></p>
<ul>
<li>若 <code>z :: f a</code>，则 <code>y :: f (a -&gt; b)</code>，<code>x :: f(b -&gt; c)</code>，</li>
<li>且 <code>pure (.) &lt;*&gt; x &lt;*&gt; y :: f (a -&gt; c)</code></li>
</ul>
</li>
</ol>
<p>其实后两条就是类似交换律和结合律。</p>
<h3 id="Monad-Laws"><a href="#Monad-Laws" class="headerlink" title="Monad Laws"></a>Monad Laws</h3><p>任何一个 Monad 的实例，都必须满足如下性质：</p>
<ol>
<li><p>Left identity（左单位律）</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- :: m a       :: a -&gt; m b</span></span><br><span class="line"><span class="comment">-- ↓↓↓↓↓↓↓↓     ↓</span></span><br><span class="line">   return x &gt;&gt;= h  ===  h x</span><br><span class="line"><span class="comment">--                      ↑↑↑</span></span><br><span class="line"><span class="comment">--                      :: m b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Right identity（右单位律）</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- :: m a :: a -&gt; m a</span></span><br><span class="line"><span class="comment">-- ↓↓     ↓↓↓↓↓↓</span></span><br><span class="line">   mx &gt;&gt;= return  ===  mx</span><br><span class="line"><span class="comment">--                     ↑↑</span></span><br><span class="line"><span class="comment">--                     :: m a</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Associativity（结合律）</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  :: m a</span></span><br><span class="line"><span class="comment">--  ┊┊     :: a -&gt; m b</span></span><br><span class="line"><span class="comment">--  ┊┊     ┊      :: b -&gt; m c      :: a :: m c</span></span><br><span class="line"><span class="comment">--  ↓↓     ↓      ↓                ↓    ↓↓↓↓↓↓↓↓↓</span></span><br><span class="line">   (mx &gt;&gt;= g) &gt;&gt;= h  ===  mx &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</span><br><span class="line"><span class="comment">--  ↑↑↑↑↑↑↑↑                      ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"><span class="comment">--  :: m b                        :: a -&gt; m c</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>至于为什么叫做这三个，可以用如下方式来解释：Haskell 的 <code>Control.Monad</code> 模块中按照如下方式定义了运算符 <code>&gt;==&gt;</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- The monad-composition operator</span></span><br><span class="line"><span class="comment">-- defined in Control.Monad</span></span><br><span class="line">(&gt;=&gt;) :: <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span><br><span class="line"></span><br><span class="line"><span class="comment">--          :: a :: m b  :: b -&gt; m c</span></span><br><span class="line"><span class="comment">--          ↓    ↓↓↓     ↓</span></span><br><span class="line"><span class="title">f</span> &gt;=&gt; g  = \x -&gt; f x &gt;&gt;= g</span><br><span class="line"><span class="comment">--               ↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"><span class="comment">--               :: m c</span></span><br></pre></td></tr></table></figure>

<p>简单来说就是把两个函数合并到一个函数上。那么我们可以对三个 Law 分别做一些变换：</p>
<ol>
<li><p>Left identity</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">              return x &gt;&gt;= h      ===  h x</span><br><span class="line">&lt;==&gt;         (return x &gt;&gt;= h)     ===  h x</span><br><span class="line">&lt;==&gt;  (\y -&gt; (return y &gt;&gt;= h)) x  ===  h x</span><br><span class="line">&lt;==&gt;  (       return   &gt;=&gt; h ) x  ===  h x</span><br><span class="line">&lt;==&gt;  (       return   &gt;=&gt; h )    ===  h</span><br><span class="line">&lt;==&gt;          return   &gt;=&gt; h      ===  h</span><br></pre></td></tr></table></figure>

<p>其实就是在说 <code>return</code> 是 <code>&gt;==&gt;</code> 的左单位元。</p>
</li>
<li><p>Right identity</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">            mx  &gt;&gt;= return     ===  mx</span><br><span class="line">&lt;==&gt;        f x &gt;&gt;= return     ===  f x</span><br><span class="line">&lt;==&gt; (\y -&gt; f y &gt;&gt;= return) x  ===  f x</span><br><span class="line">&lt;==&gt; (      f   &gt;=&gt; return) x  ===  f x</span><br><span class="line">&lt;==&gt; (      f   &gt;=&gt; return)    ===  f</span><br><span class="line">&lt;==&gt;        f   &gt;=&gt; return     ===  f</span><br></pre></td></tr></table></figure>

<p>其实就是在说 <code>return</code> 是 <code>&gt;==&gt;</code> 的右单位元。</p>
</li>
<li><p>Associativity</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">            (      my  &gt;&gt;= g)   &gt;&gt;= h    ===        my  &gt;&gt;= (\y -&gt; g y &gt;&gt;= h)</span><br><span class="line">&lt;==&gt;        (      f x &gt;&gt;= g)   &gt;&gt;= h    ===        f x &gt;&gt;= (\y -&gt; g y &gt;&gt;= h)</span><br><span class="line">&lt;==&gt;        (      f x &gt;&gt;= g)   &gt;&gt;= h    ===        f x &gt;&gt;= (      g   &gt;=&gt; h)</span><br><span class="line">&lt;==&gt;        (\u -&gt; f u &gt;&gt;= g) x &gt;&gt;= h    ===        f x &gt;&gt;= (      g   &gt;=&gt; h)</span><br><span class="line">&lt;==&gt;        (      f   &gt;=&gt; g) x &gt;&gt;= h    ===        f x &gt;&gt;= (      g   &gt;=&gt; h)</span><br><span class="line">&lt;==&gt; (\u -&gt; (      f   &gt;=&gt; g) u &gt;&gt;= h) x === (\u -&gt; f u &gt;&gt;= (      g   &gt;=&gt; h)) x</span><br><span class="line">&lt;==&gt; (\u -&gt; (      f   &gt;=&gt; g) u &gt;&gt;= h)   === (\u -&gt; f u &gt;&gt;= (      g   &gt;=&gt; h))</span><br><span class="line">&lt;==&gt; (      (      f   &gt;=&gt; g)   &gt;=&gt; h)   === (      f   &gt;=&gt; (      g   &gt;=&gt; h))</span><br></pre></td></tr></table></figure>

<p>其实就是在说 <code>&gt;==&gt;</code> 满足结合律。</p>
</li>
</ol>
<h2 id="一些-Monad"><a href="#一些-Monad" class="headerlink" title="一些 Monad"></a>一些 Monad</h2><h3 id="State-Monad"><a href="#State-Monad" class="headerlink" title="State Monad"></a>State Monad</h3><p>考虑下面这个问题：有一个 <code>Tree a</code> 类型，他按以下方式来定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Leaf</span> a | <span class="type">Node</span> (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br></pre></td></tr></table></figure>

<p>也就是只有叶子节点会存放一个 <code>a</code> 类型的值。现在我们希望实现一个函数 <code>relable :: Tree a -&gt; Tree Int</code>，来给每个叶子节点重新标号。如果按照普通函数的方式来写，那么就需要传回一个 pair，一个表示结果，一个表示当前用到的标号：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">rlabel</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Int</span> -&gt; <span class="type">Tree</span> <span class="type">Int</span></span><br><span class="line"><span class="title">rlabel</span> (<span class="type">Leaf</span> _) n = (<span class="type">Leaf</span> n, n + <span class="number">1</span>)</span><br><span class="line"><span class="title">rlable</span> (<span class="type">Node</span> l r) n = ((<span class="type">Node</span> l&#x27; r&#x27;) n&#x27;&#x27;) <span class="keyword">where</span></span><br><span class="line">  (l&#x27;, n&#x27; ) = rlable l n</span><br><span class="line">  (r&#x27;, n&#x27;&#x27;) = rlable r n&#x27;</span><br><span class="line"></span><br><span class="line"><span class="title">relable</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Tree</span> <span class="type">Int</span></span><br><span class="line"><span class="title">relable</span> t = fst (rlable t <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用 State Monad，我们就能做到不显示维护这些值。我们先来定义 <code>StateTrans</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">State</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">StateTrans</span> a = <span class="type">ST</span> (<span class="type">State</span> -&gt; (<span class="title">a</span>, <span class="type">State</span>))</span></span><br></pre></td></tr></table></figure>

<p>这里 <code>StateTrans</code> 就是对 <code>State</code> 进行某种变化，但是中间可能会产出一个需要的值，类型为 <code>a</code>。在上面的例子中，<code>State</code> 即为我们要存的当前标到的号，而 <code>a</code> 即为产出的结果。</p>
<p>为了下面定义方便，我们再定义一个函数 <code>app</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">app</span> :: <span class="type">StateTrans</span> a -&gt; <span class="type">State</span> -&gt; (a, <span class="type">State</span>)</span><br><span class="line"><span class="title">app</span> (<span class="type">ST</span> f) s = f s</span><br></pre></td></tr></table></figure>

<p>其实就是把 <code>StateTrans</code> 里面的函数拿出来作用一下。</p>
<p>先来看一下应该如何把 <code>StateTrans</code> 变为 Functor，Applicative 和 Monad 的实例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">StateTrans</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap g st = <span class="type">ST</span> $ \s -&gt; <span class="keyword">let</span> (x, s&#x27;) = app st s <span class="keyword">in</span> (g x, s&#x27;)</span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">StateTrans</span> <span class="keyword">where</span></span></span><br><span class="line">  pure x = <span class="type">ST</span> $ \s -&gt; (x, s)</span><br><span class="line">  stf &lt;*&gt; stx = <span class="type">ST</span> $ \s -&gt; <span class="keyword">let</span> (f, s&#x27; ) = app stf s</span><br><span class="line">                               (x, s&#x27;&#x27;) = app stx s&#x27;</span><br><span class="line">                           <span class="keyword">in</span> (f x, s&#x27;&#x27;)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">StateTrans</span> <span class="keyword">where</span></span></span><br><span class="line">  return x = <span class="type">ST</span> $ \s -&gt; (x, s)</span><br><span class="line">  st &gt;&gt;= f = <span class="type">ST</span> $ \s -&gt; <span class="keyword">let</span> (x, s&#x27;) = app st s</span><br><span class="line">                        <span class="keyword">in</span> app (f x) s&#x27;</span><br></pre></td></tr></table></figure>

<p>三个定义都很自然。那么现在我们就可以尝试用 State Monad 来定义 <code>relable</code> 函数了：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fresh</span> :: <span class="type">StateTrans</span> <span class="type">Int</span></span><br><span class="line"><span class="title">fresh</span> = <span class="type">ST</span> $n -&gt; (n, n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">mlable</span> :: <span class="type">Tree</span> a -&gt; <span class="type">StateTrans</span> (<span class="type">Tree</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">mlable</span> (<span class="type">Leaf</span> _) = fresh &gt;&gt;= \n -&gt; return $ <span class="type">Leaf</span> n</span><br><span class="line"><span class="title">mlable</span> (<span class="type">Node</span> l r) = mlable l &gt;&gt;= \l&#x27; -&gt;</span><br><span class="line">                    mlable r &gt;&gt;= \r&#x27; -&gt;</span><br><span class="line">                    return $ <span class="type">Node</span> l&#x27; r&#x27;</span><br><span class="line"></span><br><span class="line"><span class="title">relable</span> :: <span class="type">Tree</span> a -&gt; <span class="type">Tree</span> <span class="type">Int</span></span><br><span class="line"><span class="title">relable</span> t = fst $ app (mlable t) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当然也可以把 <code>mlable</code> 写成 Do 表达式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mlable</span> (<span class="type">Leaf</span> _) = <span class="keyword">do</span> n &lt;- fresh</span><br><span class="line">                     return $ <span class="type">Leaf</span> n</span><br><span class="line"><span class="title">mlabe</span> (<span class="type">Node</span> l r) = <span class="keyword">do</span> l&#x27; &lt;- mlable l</span><br><span class="line">                      r&#x27; &lt;- mlable r</span><br><span class="line">                      return $ <span class="type">Node</span> l&#x27; r&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="r-Monad"><a href="#r-Monad" class="headerlink" title="(-&gt;) r Monad"></a><code>(-&gt;) r</code> Monad</h3><p>注意到 <code>a -&gt; b</code> 可以被写作 <code>(-&gt;) a b</code>，也就是说 <code>-&gt;</code> 其实也是一个 type constructor，他接收两个 type <code>a</code> 和 <code>b</code>，返回一个 <code>a -&gt; b</code> 的 type。但是我们并不能直接对 <code>-&gt;</code> 来定义 Monad，因为 Monad 只能定义在接收一个 type 的 type constructor 上。</p>
<p>但是发现 Haskell 的函数都是 Curry 化的，因此如果我们给定了 <code>a</code>，他么他就只需要接收一个 type 了。也就是说 <code>(-&gt;) r</code> 其实是一个接收一个 type 的 type constructor。</p>
<p>我们来尝试定义 <code>(-&gt;) r</code> 的 Functor，Applicative 和 Monad：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  fmap = (.)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  pure = const</span><br><span class="line">  g &lt;*&gt; h = \x -&gt; g x $ h x</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">  return = const</span><br><span class="line">  g &gt;&gt;= h = \x -&gt; h (g x) x</span><br></pre></td></tr></table></figure>

<p>此时我们很难把 <code>(-&gt;) r</code> 看作一个装东西的盒子，这三个函数的定义也就没有这么显然了。但是我们可以用类型推导的方式来做出上面三个定义，分别来看：</p>
<ul>
<li><p>对于 <code>Functor</code>，有：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</span><br><span class="line"><span class="title">fmap</span> g h = \x -&gt; g (h x)</span><br><span class="line"><span class="title">fmap</span> = (.)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 <code>Applicative</code>，有：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;*&gt;) :: (r -&gt; a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</span><br><span class="line"><span class="title">g</span> &lt;*&gt; h = \x -&gt; g x $ h x</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 <code>Monad</code>，有：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: f a -&gt; (a -&gt; f b) -&gt; f b</span><br><span class="line">(&gt;&gt;=) :: (r -&gt; a) -&gt; (a -&gt; r -&gt; b) -&gt; (r -&gt; b)</span><br><span class="line"><span class="title">g</span> &gt;&gt;= h = \x -&gt; h (g x) x</span><br></pre></td></tr></table></figure></li>
</ul>
<p>因此类型推导也能帮助我们来定义一些较抽象 type constructor 的 Monad。</p>
<h3 id="Expr-Monad"><a href="#Expr-Monad" class="headerlink" title="Expr Monad"></a>Expr Monad</h3><p><code>Expr</code> 是我们自己定义的一个 type，我们也可以对其定义 Monad：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> a</span></span><br><span class="line">  = <span class="type">Var</span> a</span><br><span class="line">  | <span class="type">Val</span> <span class="type">Int</span></span><br><span class="line">  | <span class="type">Add</span> (<span class="type">Expr</span> a) (<span class="type">Expr</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  fmap f (<span class="type">Var</span> x) = <span class="type">Var</span> $ f x</span><br><span class="line">  fmap _ (<span class="type">Val</span> x) = <span class="type">Val</span> x</span><br><span class="line">  fmap f (<span class="type">Add</span> x y) = <span class="type">Add</span> (fmap f x) (fmap f y)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  pure = <span class="type">Var</span></span><br><span class="line">  (<span class="type">Var</span> f) &lt;*&gt; t = fmap f t</span><br><span class="line">  (<span class="type">Val</span> x) &lt;*&gt; _ = <span class="type">Val</span> x</span><br><span class="line">  (<span class="type">Add</span> x y) &lt;*&gt; t = <span class="type">Add</span> (x &lt;*&gt; t) (y &lt;*&gt; t)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Expr</span> <span class="keyword">where</span></span></span><br><span class="line">  return = <span class="type">Var</span></span><br><span class="line">  (<span class="type">Var</span> x) &gt;&gt;= f = f x</span><br><span class="line">  (<span class="type">Val</span> x) &gt;&gt;= _ = <span class="type">Val</span> x</span><br><span class="line">  (<span class="type">Add</span> x y) &gt;&gt;= f = <span class="type">Add</span> (x &gt;&gt;= f) (y &gt;&gt;= f)</span><br></pre></td></tr></table></figure>

<p>这些函数定义都比较显然，摘自作业。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>NetSpeed1</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://enucai.github.io/2025/10/25/haskell-monad/">https://enucai.github.io/2025/10/25/haskell-monad/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/haskell/"># haskell</a>
                    
                        <a href="/tags/functional-programming/"># functional programming</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/10/30/mathana-1-midterm/">数学分析（I）期中复习</a>
            
            
            <a class="next" rel="next" href="/2025/10/10/authored-problem/">我的算法竞赛题目</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© NetSpeed1 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>